<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1200 ELO Chess Bot</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin-top: 50px; 
            background-color: #f4f4f9;
        }
        /* touch-action: none stops the page from scrolling on mobile when dragging pieces */
        #myBoard { 
            width: 400px; 
            max-width: 100%; 
            touch-action: none; 
        }
        .status { margin-top: 20px; font-size: 1.2rem; font-weight: bold; }
        .explanation { margin-top: 10px; color: #555; max-width: 400px; text-align: center; }
    </style>
</head>
<body>

    <h2>Play White vs. an ~1200 ELO Bot</h2>
    <div id="myBoard"></div>
    <div class="status" id="status">Your turn (White)</div>
    <p class="explanation">This bot looks ahead 2 moves into the future to calculate its best response using the Minimax algorithm.</p>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        var board = null;
        var game = new Chess();
        var $status = $('#status');

        // Piece values for the bot to evaluate the board
        var pieceValues = { 'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900 };

        // Evaluates the current board state. Positive score = White is winning, Negative = Black is winning.
        function evaluateBoard(game) {
            var totalEvaluation = 0;
            var boardArray = game.board();
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    totalEvaluation += getPieceValue(boardArray[i][j]);
                }
            }
            return totalEvaluation;
        }

        function getPieceValue(piece) {
            if (piece === null) return 0;
            var val = pieceValues[piece.type];
            return piece.color === 'w' ? val : -val;
        }

        // Minimax algorithm with Alpha-Beta pruning to look ahead efficiently
        function minimax(game, depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game);
            }

            var possibleMoves = game.moves();

            if (isMaximizingPlayer) {
                var bestVal = -9999;
                for (var i = 0; i < possibleMoves.length; i++) {
                    game.move(possibleMoves[i]);
                    bestVal = Math.max(bestVal, minimax(game, depth - 1, alpha, beta, !isMaximizingPlayer));
                    game.undo();
                    alpha = Math.max(alpha, bestVal);
                    if (beta <= alpha) break;
                }
                return bestVal;
            } else {
                var bestVal = 9999;
                for (var i = 0; i < possibleMoves.length; i++) {
                    game.move(possibleMoves[i]);
                    bestVal = Math.min(bestVal, minimax(game, depth - 1, alpha, beta, !isMaximizingPlayer));
                    game.undo();
                    beta = Math.min(beta, bestVal);
                    if (beta <= alpha) break;
                }
                return bestVal;
            }
        }

        // The Bot's brain
        function makeBotMove() {
            var possibleMoves = game.moves();
            if (possibleMoves.length === 0) return;

            var bestMove = null;
            var bestValue = 9999; // Bot plays Black, so it wants the lowest score possible

            // Look through all immediate moves
            for (var i = 0; i < possibleMoves.length; i++) {
                var move = possibleMoves[i];
                game.move(move);
                
                // Calculate what happens 2 moves into the future
                var boardValue = minimax(game, 2, -10000, 10000, true);
                game.undo();
                
                if (boardValue < bestValue) {
                    bestValue = boardValue;
                    bestMove = move;
                }
            }

            // Fallback in case of weird edge cases
            if (!bestMove) {
                bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }

            game.move(bestMove);
            board.position(game.fen());
            updateStatus();
        }

        function onDragStart (source, piece, position, orientation) {
            if (game.game_over() || piece.search(/^b/) !== -1) {
                return false;
            }
        }

        function onDrop (source, target) {
            var move = game.move({
                from: source,
                to: target,
                promotion: 'q'
            });

            if (move === null) return 'snapback';
            
            updateStatus();
            window.setTimeout(makeBotMove, 250);
        }

        function onSnapEnd () {
            board.position(game.fen());
        }

        function updateStatus () {
            var statusHTML = '';
            var moveColor = game.turn() === 'b' ? 'Black' : 'White';

            if (game.in_checkmate()) {
                statusHTML = 'Game over, ' + moveColor + ' is in checkmate.';
            } else if (game.in_draw()) {
                statusHTML = 'Game over, drawn position';
            } else {
                statusHTML = moveColor + ' to move';
                if (game.in_check()) {
                    statusHTML += ', ' + moveColor + ' is in check';
                }
            }
            $status.html(statusHTML);
        }

        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd,
            // Link directly to the piece images so they actually load
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png' 
        };
        
        board = Chessboard('myBoard', config);
        updateStatus();
    </script>
</body>
</html>
